import json
from datetime import datetime
from pathlib import Path
from typing import List, Dict

from .task_generator import get_task_type_summary, get_priority_summary


def generate_health_report(results: List[Dict], repo_path: str) -> None:
    """
    Generate a health report in Markdown format based on analysis results.

    Args:
        results: List of complexity issues found during analysis
        repo_path: Path to the repository root
    """
    repo_path = Path(repo_path)
    reports_dir = repo_path / ".evolver" / "reports"

    # Ensure the reports directory exists
    reports_dir.mkdir(parents=True, exist_ok=True)

    report_path = reports_dir / "HEALTH_REPORT.md"

    # Generate the report content
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    content = f"""# ðŸ¥ EvolverAgent Health Report

**Generated on:** {timestamp}  
**Repository:** Primoia Monorepo  
**Analyzer:** EvolverAgent MVP

## ðŸ“Š Summary

Total complexity issues found: **{len(results)}**

"""

    if not results:
        content += """## âœ… No Issues Found

Great news! No functions or methods were found with cyclomatic complexity exceeding 10.
The codebase appears to be well-structured from a complexity perspective.

"""
    else:
        # Group results by file for better organization
        files_with_issues = {}
        for issue in results:
            file_path = issue["file"]
            if file_path not in files_with_issues:
                files_with_issues[file_path] = []
            files_with_issues[file_path].append(issue)

        content += f"""## âš ï¸ Complexity Issues

Found {len(results)} functions/methods with cyclomatic complexity > 10 across {len(files_with_issues)} files.

### ðŸ“‹ Issues by File

"""

        # Sort files by number of issues (descending)
        sorted_files = sorted(
            files_with_issues.items(), key=lambda x: len(x[1]), reverse=True
        )

        for file_path, file_issues in sorted_files:
            content += f"#### ðŸ“ `{file_path}`\n\n"
            content += f"Issues found: **{len(file_issues)}**\n\n"

            # Sort issues by complexity (descending)
            sorted_issues = sorted(
                file_issues, key=lambda x: x["complexity"], reverse=True
            )

            for issue in sorted_issues:
                complexity_level = get_complexity_level(issue["complexity"])
                content += f"- **{issue['function']}** (Line {issue['line']}) - "
                content += f"Complexity: **{issue['complexity']}** {complexity_level}\n"

            content += "\n"

    # Add recommendations section
    content += """## ðŸ”§ Recommendations

### High Priority
- Functions with complexity > 15 should be refactored immediately
- Consider breaking down complex functions into smaller, focused methods

### Medium Priority  
- Functions with complexity 11-15 should be reviewed and potentially simplified
- Add unit tests for complex functions to ensure refactoring safety

### Best Practices
- Aim for cyclomatic complexity < 10 for all functions
- Use early returns to reduce nesting levels
- Extract complex conditional logic into separate methods
- Consider using design patterns to simplify complex workflows

## ðŸ“ˆ Next Steps

1. **Priority Refactoring**: Address the highest complexity functions first
2. **Code Review**: Have team members review complex functions
3. **Testing**: Ensure adequate test coverage before refactoring
4. **Monitoring**: Run EvolverAgent regularly to track improvements

---
*This report was automatically generated by EvolverAgent MVP*
"""

    # Write the report to file
    with open(report_path, "w", encoding="utf-8") as f:
        f.write(content)

    print(f"Health report generated: {report_path}")


def get_complexity_level(complexity: int) -> str:
    """
    Get a visual indicator for complexity level.

    Args:
        complexity: The cyclomatic complexity value

    Returns:
        String with emoji indicator for complexity level
    """
    if complexity >= 20:
        return "ðŸ”´ Critical"
    elif complexity >= 15:
        return "ðŸŸ¡ High"
    elif complexity >= 11:
        return "ðŸŸ  Medium"
    else:
        return "ðŸŸ¢ Low"


def generate_summary_stats(results: List[Dict]) -> Dict:
    """
    Generate summary statistics from analysis results.

    Args:
        results: List of complexity issues

    Returns:
        Dictionary with summary statistics
    """
    if not results:
        return {
            "total_issues": 0,
            "average_complexity": 0,
            "max_complexity": 0,
            "files_affected": 0,
        }

    complexities = [issue["complexity"] for issue in results]
    files_affected = len(set(issue["file"] for issue in results))

    return {
        "total_issues": len(results),
        "average_complexity": round(sum(complexities) / len(complexities), 2),
        "max_complexity": max(complexities),
        "files_affected": files_affected,
    }


def generate_task_suggestions_json(tasks: List[Dict], repo_path: str) -> None:
    """
    Generate the TASK_SUGGESTIONS.json file with actionable tasks.

    Args:
        tasks: List of task suggestions
        repo_path: Path to the repository root
    """
    repo_path = Path(repo_path)
    reports_dir = repo_path / ".evolver" / "reports"

    # Ensure the reports directory exists
    reports_dir.mkdir(parents=True, exist_ok=True)

    suggestions_path = reports_dir / "TASK_SUGGESTIONS.json"

    # Add metadata
    output = {
        "metadata": {
            "generated_at": datetime.now().isoformat(),
            "agent_version": "Phase2-1.0",
            "total_tasks": len(tasks),
            "task_types": get_task_type_summary(tasks),
            "priority_distribution": get_priority_summary(tasks),
        },
        "tasks": tasks,
    }

    with open(suggestions_path, "w", encoding="utf-8") as f:
        json.dump(output, f, indent=2, ensure_ascii=False)

    print(f"Task suggestions generated: {suggestions_path}")


def generate_enhanced_health_report(
    complexity_results: List[Dict],
    security_results: List[Dict],
    dependency_results: List[Dict],
    repo_path: str,
) -> None:
    """
    Generate an enhanced health report including security and dependency analysis.

    Args:
        complexity_results: List of complexity issues
        security_results: List of security issues
        dependency_results: List of dependency vulnerabilities
        repo_path: Path to the repository root
    """
    repo_path = Path(repo_path)
    reports_dir = repo_path / ".evolver" / "reports"

    # Ensure the reports directory exists
    reports_dir.mkdir(parents=True, exist_ok=True)

    report_path = reports_dir / "HEALTH_REPORT.md"

    # Generate the report content
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    content = f"""# ðŸ¥ EvolverAgent Health Report

**Generated on:** {timestamp}  
**Repository:** Primoia Monorepo  
**Analyzer:** EvolverAgent Phase 2

## ðŸ“Š Executive Summary

| Category | Issues Found | Status |
|----------|--------------|--------|
| ðŸ§  Complexity | {len(complexity_results)} | {get_status_indicator(len(complexity_results))} |
| ðŸ”’ Security | {len(security_results)} | {get_status_indicator(len(security_results))} |
| ðŸ“¦ Dependencies | {len(dependency_results)} | {get_status_indicator(len(dependency_results))} |

"""

    # Add complexity section
    if complexity_results:
        content += generate_complexity_section(complexity_results)
    else:
        content += """## âœ… Code Complexity

Great news! No functions or methods were found with cyclomatic complexity exceeding 10.
The codebase appears to be well-structured from a complexity perspective.

"""

    # Add security section
    if security_results:
        content += generate_security_section(security_results)
    else:
        content += """## ðŸ”’ Security Analysis

No security issues detected by static analysis tools.
The codebase appears to follow secure coding practices.

"""

    # Add dependency section
    if dependency_results:
        content += generate_dependency_section(dependency_results)
    else:
        content += """## ðŸ“¦ Dependency Security

No known vulnerabilities found in project dependencies.
All dependencies appear to be up-to-date and secure.

"""

    # Add recommendations section
    content += generate_recommendations_section(
        complexity_results, security_results, dependency_results
    )

    # Add footer
    content += """
---
*This report was automatically generated by EvolverAgent Phase 2*
"""

    # Write the report to file
    with open(report_path, "w", encoding="utf-8") as f:
        f.write(content)

    print(f"Enhanced health report generated: {report_path}")


def get_status_indicator(count: int) -> str:
    """Get status indicator based on issue count."""
    if count == 0:
        return "ðŸŸ¢ Good"
    elif count <= 5:
        return "ðŸŸ¡ Fair"
    else:
        return "ðŸ”´ Needs Attention"


def generate_complexity_section(complexity_results: List[Dict]) -> str:
    """Generate complexity section of the health report."""
    # Group results by file
    files_with_issues = {}
    for issue in complexity_results:
        file_path = issue["file"]
        if file_path not in files_with_issues:
            files_with_issues[file_path] = []
        files_with_issues[file_path].append(issue)

    content = f"""## ðŸ§  Code Complexity Analysis

Found {len(complexity_results)} functions/methods with cyclomatic complexity > 10 across {len(files_with_issues)} files.

### ðŸ“‹ Top Complexity Issues

"""

    # Sort by complexity (descending) and show top 10
    top_issues = sorted(
        complexity_results, key=lambda x: x["complexity"], reverse=True
    )[:10]

    for issue in top_issues:
        complexity_level = get_complexity_level(issue["complexity"])
        content += f"- **{issue['function']}** in `{issue['file']}:{issue['line']}` - "
        content += f"Complexity: **{issue['complexity']}** {complexity_level}\n"

    if len(complexity_results) > 10:
        content += f"\n*... and {len(complexity_results) - 10} more issues*\n"

    content += "\n"
    return content


def generate_security_section(security_results: List[Dict]) -> str:
    """Generate security section of the health report."""
    # Group by severity
    by_severity = {}
    for issue in security_results:
        severity = issue["severity"]
        if severity not in by_severity:
            by_severity[severity] = []
        by_severity[severity].append(issue)

    content = f"""## ðŸ”’ Security Analysis

Found {len(security_results)} potential security issues requiring attention.

### ðŸš¨ Security Issues by Severity

"""

    # Show issues by severity
    for severity in ["critical", "high", "medium", "low"]:
        if severity in by_severity:
            issues = by_severity[severity]
            severity_icon = get_severity_icon(severity)
            content += (
                f"#### {severity_icon} {severity.title()} ({len(issues)} issues)\n\n"
            )

            for issue in issues[:5]:  # Show top 5 per severity
                content += f"- **{issue['test_name']}** in `{issue['file']}:{issue['line_number']}`\n"
                content += f"  - {issue['issue_text']}\n"

            if len(issues) > 5:
                content += f"  - *... and {len(issues) - 5} more {severity} issues*\n"
            content += "\n"

    return content


def generate_dependency_section(dependency_results: List[Dict]) -> str:
    """Generate dependency section of the health report."""
    # Group by severity
    by_severity = {}
    for issue in dependency_results:
        severity = issue["severity"]
        if severity not in by_severity:
            by_severity[severity] = []
        by_severity[severity].append(issue)

    unique_packages = set(issue["package"] for issue in dependency_results)

    content = f"""## ðŸ“¦ Dependency Vulnerabilities

Found {len(dependency_results)} vulnerabilities in {len(unique_packages)} packages.

### ðŸš¨ Vulnerable Dependencies by Severity

"""

    # Show dependencies by severity
    for severity in ["critical", "high", "medium", "low"]:
        if severity in by_severity:
            issues = by_severity[severity]
            severity_icon = get_severity_icon(severity)
            content += f"#### {severity_icon} {severity.title()} ({len(issues)} vulnerabilities)\n\n"

            for issue in issues[:5]:  # Show top 5 per severity
                content += f"- **{issue['package']}** {issue['version']} in `{issue['file']}`\n"
                content += f"  - {issue['advisory']}\n"
                if issue.get("safe_versions"):
                    content += f"  - Safe versions: {issue['safe_versions']}\n"

            if len(issues) > 5:
                content += (
                    f"  - *... and {len(issues) - 5} more {severity} vulnerabilities*\n"
                )
            content += "\n"

    return content


def generate_recommendations_section(
    complexity_results: List[Dict],
    security_results: List[Dict],
    dependency_results: List[Dict],
) -> str:
    """Generate recommendations section."""
    content = """## ðŸ”§ Recommendations

### ðŸš¨ Immediate Actions Required
"""

    # Critical issues first
    critical_security = [r for r in security_results if r["severity"] == "critical"]
    critical_deps = [r for r in dependency_results if r["severity"] == "critical"]
    critical_complexity = [r for r in complexity_results if r["complexity"] >= 20]

    if critical_security or critical_deps or critical_complexity:
        if critical_security:
            content += (
                f"- Fix {len(critical_security)} critical security issues immediately\n"
            )
        if critical_deps:
            content += (
                f"- Update {len(critical_deps)} critical dependency vulnerabilities\n"
            )
        if critical_complexity:
            content += f"- Refactor {len(critical_complexity)} highly complex functions (complexity â‰¥ 20)\n"
    else:
        content += "- No critical issues requiring immediate attention\n"

    content += """
### ðŸ“… Short-term Goals (1-2 weeks)
- Address high-priority security and dependency issues
- Refactor functions with complexity > 15
- Add unit tests for complex functions before refactoring

### ðŸ“ˆ Long-term Improvements (1 month+)
- Establish code complexity monitoring in CI/CD pipeline
- Implement security scanning in development workflow
- Regular dependency updates and vulnerability scanning
- Code review guidelines focusing on complexity and security

### ðŸ› ï¸ Automation Opportunities
- Set up automated dependency updates (Dependabot/Renovate)
- Integrate security scanning into pull request checks
- Add complexity analysis to code review process
- Implement automated refactoring suggestions

"""

    return content


def get_severity_icon(severity: str) -> str:
    """Get icon for severity level."""
    icons = {"critical": "ðŸ”´", "high": "ðŸŸ ", "medium": "ðŸŸ¡", "low": "ðŸŸ¢"}
    return icons.get(severity, "âšª")
