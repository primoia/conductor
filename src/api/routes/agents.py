# src/api/routes/agents.py
from fastapi import APIRouter, HTTPException, Path
from typing import List, Dict, Any
from pydantic import BaseModel
from typing import Optional
import logging

# Importar da arquitetura existente
from src.container import container  # Usar inst√¢ncia global do container DI
from src.api.models import AgentListResponse, AgentSummary, AgentDetailResponse, ValidationResult
from src.core.services.mongo_task_client import MongoTaskClient

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/agents", tags=["Agents"])

# Modelo existente do server.py
class AgentExecuteRequest(BaseModel):
    user_input: str
    cwd: str
    task_id: str  # REQUIRED: Task ID generated by gateway
    timeout: Optional[int] = 600  # 10 minutes timeout for long-running operations
    provider: Optional[str] = "claude"
    instance_id: Optional[str] = None  # SAGA-003: Instance ID for isolated context
    context_mode: Optional[str] = "stateless"  # SAGA-003: "stateful" or "stateless"
    conversation_id: Optional[str] = None  # REQUIRED: Conversation ID for context
    screenplay_id: Optional[str] = None  # REQUIRED: Screenplay ID for project context
    wait_for_result: Optional[bool] = True  # If False, returns task_id immediately without waiting
    # Councilor execution fields
    is_councilor_execution: Optional[bool] = False  # Flag for councilor executions
    councilor_config: Optional[Dict[str, Any]] = None  # Councilor configuration (if applicable)

@router.get("/", response_model=AgentListResponse, summary="Listar todos os agentes")
def list_agents():
    """
    Lista todos os agentes dispon√≠veis no sistema.

    Esta rota √© uma vers√£o refatorada do endpoint GET /agents original,
    utilizando os mesmos servi√ßos mas com estrutura modular.
    """
    try:
        conductor_service = container.get_conductor_service()
        agents = conductor_service.discover_agents()

        # Usar mesma estrutura de resposta do endpoint atual
        agent_summaries = [
            AgentSummary(id=agent.agent_id, name=getattr(agent, 'name', 'N/A'))
            for agent in agents
        ]

        return AgentListResponse(total=len(agent_summaries), agents=agent_summaries)

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Erro interno ao processar a lista de agentes: {e}"
        )

@router.get("/{agent_id}/info", response_model=AgentDetailResponse, summary="Obter detalhes de um agente")
def get_agent_info(agent_id: str = Path(..., description="ID do agente a ser consultado")):
    """
    Retorna informa√ß√µes detalhadas de um agente espec√≠fico.

    Utiliza o AgentDiscoveryService para carregar a defini√ß√£o completa do agente.
    """
    try:
        discovery_service = container.get_agent_discovery_service()

        # Verificar se agente existe primeiro
        if not discovery_service.agent_exists(agent_id):
            raise HTTPException(status_code=404, detail=f"Agente '{agent_id}' n√£o encontrado")

        # Carregar defini√ß√£o completa
        definition = discovery_service.get_agent_definition(agent_id)
        if not definition:
            raise HTTPException(status_code=404, detail=f"Defini√ß√£o do agente '{agent_id}' n√£o encontrada")

        return AgentDetailResponse(
            name=definition.name,
            version=definition.version,
            schema_version=definition.schema_version,
            description=definition.description,
            author=definition.author,
            tags=definition.tags,
            capabilities=definition.capabilities,
            allowed_tools=definition.allowed_tools,
            agent_id=definition.agent_id or agent_id
        )

    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Erro interno ao carregar informa√ß√µes do agente: {e}"
        )

@router.get("/{agent_id}/validate", response_model=ValidationResult, summary="Validar configura√ß√£o de um agente")
def validate_agent(agent_id: str = Path(..., description="ID do agente a ser validado")):
    """
    Executa valida√ß√£o completa de um agente espec√≠fico.

    Verifica defini√ß√£o, estrutura de arquivos e integridade de dados.
    """
    try:
        discovery_service = container.get_agent_discovery_service()

        # Usar m√©todo de valida√ß√£o que acabamos de implementar
        is_valid, errors, warnings = discovery_service.validate_agent(agent_id)

        return ValidationResult(
            is_valid=is_valid,
            errors=errors,
            warnings=warnings,
            agent_id=agent_id
        )

    except Exception as e:
        # Se houver erro na valida√ß√£o, retornar como erro de valida√ß√£o
        return ValidationResult(
            is_valid=False,
            errors=[f"Erro durante valida√ß√£o: {str(e)}"],
            warnings=[],
            agent_id=agent_id
        )

@router.post("/{agent_id}/execute", response_model=Dict[str, Any], summary="Executar um agente")
def execute_agent(agent_id: str, request: AgentExecuteRequest):
    """
    Executa um agente espec√≠fico via MongoDB queue system.

    SAGA-004: Hist√≥rico por instance_id √© gerenciado automaticamente via collection 'history'.
    """
    if MongoTaskClient is None:
        raise HTTPException(status_code=503, detail="MongoDB client n√£o est√° dispon√≠vel")

    try:
        task_client = MongoTaskClient()
        discovery_service = container.get_agent_discovery_service()

        # Obter agent_definition para determinar provider com fallback
        agent_definition = discovery_service.get_agent_definition(agent_id)
        if not agent_definition:
            raise HTTPException(status_code=404, detail=f"Agente '{agent_id}' n√£o encontrado")

        # üîç LOG DETALHADO PARA RASTREAR PROVIDER E CONTEXT
        logger.info("üîç [AGENTS] Determinando provider:")
        logger.info(f"   - request.provider: {request.provider}")
        logger.info(f"   - request.context_mode: {request.context_mode}")
        logger.info(f"   - agent_definition: {agent_definition}")
        logger.info(f"   - agent_ai_provider: {getattr(agent_definition, 'ai_provider', 'N/A')}")

        # Determinar provider com fallback hier√°rquico
        provider = container.get_ai_provider(
            agent_definition=agent_definition,
            cli_provider=request.provider
        )
        
        logger.info(f"‚úÖ [AGENTS] Provider final: {provider}")

        # Build XML prompt
        # Note: Se conversation_id for fornecido, o hist√≥rico ser√° buscado da conversa
        # IMPORTANTE: Se tem conversation_id, SEMPRE incluir hist√≥rico (ignora context_mode)
        # context_mode="stateless" s√≥ se aplica quando N√ÉO h√° conversation_id
        include_history = bool(request.conversation_id) or (request.context_mode != "stateless")

        logger.info(f"üîç [AGENTS] Decis√£o de hist√≥rico:")
        logger.info(f"   - conversation_id presente: {bool(request.conversation_id)}")
        logger.info(f"   - context_mode: {request.context_mode}")
        logger.info(f"   - include_history final: {include_history}")

        xml_prompt = discovery_service.get_full_prompt(
            agent_id=agent_id,
            current_message=request.user_input,
            meta=False,
            new_agent_id=None,
            include_history=include_history,
            save_to_file=False,
            conversation_id=request.conversation_id,  # üî• REQUIRED: Pass conversation_id to get history
            screenplay_id=request.screenplay_id,  # üî• REQUIRED: Pass screenplay_id for project context
            instance_id=request.instance_id  # üî• REQUIRED: Pass instance_id for isolated context
        )

        # üîç DEBUG: Verificar se o prompt est√° correto
        logger.info(f"üîç [AGENTS] Prompt constru√≠do:")
        logger.info(f"   - Tamanho: {len(xml_prompt)} chars")
        logger.info(f"   - Tem tags XML: {'<persona>' in xml_prompt}")
        logger.info(f"   - Primeiros 200 chars: {xml_prompt[:200]}")

        # Submete a tarefa (task_id vem do gateway)
        task_id = task_client.submit_task(
            task_id=request.task_id,  # üî• Gateway-generated task_id
            agent_id=agent_id,
            cwd=request.cwd,
            timeout=request.timeout,
            provider=provider,
            prompt=xml_prompt,
            instance_id=request.instance_id,  # üî• REQUIRED: Pass instance_id to task
            conversation_id=request.conversation_id,  # üî• REQUIRED: Pass conversation_id to task
            screenplay_id=request.screenplay_id,  # üî• REQUIRED: Pass screenplay_id to task
            is_councilor_execution=request.is_councilor_execution,  # Councilor flag
            councilor_config=request.councilor_config  # Councilor config (if applicable)
        )

        # Check if caller wants to wait for result or get task_id immediately
        if not request.wait_for_result:
            # Return task_id immediately for async/SSE pattern
            logger.info(f"‚úÖ [AGENTS] Task {task_id} submitted, returning immediately (async mode)")
            return {
                "_id": task_id,
                "status": "pending",
                "message": "Task submitted successfully, use task_id to monitor progress"
            }

        # Default behavior: wait for result (blocking)
        logger.info(f"‚è≥ [AGENTS] Waiting for task {task_id} to complete (sync mode)")
        result_document = task_client.get_task_result(task_id=task_id, timeout=request.timeout)

        # SAGA-004: Hist√≥rico j√° foi salvo automaticamente pelo TaskExecutionService
        # com o instance_id correto na collection 'history'

        return result_document

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.put("/history/{history_id}/delete", summary="Marcar mensagem do hist√≥rico como deletada")
def soft_delete_history_message(history_id: str = Path(..., description="ID da mensagem (_id do MongoDB)")):
    """
    Marca uma mensagem do hist√≥rico como deletada (soft delete).

    A mensagem n√£o √© removida do banco, mas recebe o campo isDeleted: true,
    fazendo com que seja exclu√≠da do prompt montado pelo PromptEngine.

    Args:
        history_id: ID √∫nico da mensagem (_id do MongoDB)

    Returns:
        Objeto com success: true/false e message
    """
    try:
        storage_service = container.get_storage_service()
        repository = storage_service.get_repository()

        # Atualizar documento com isDeleted: true
        result = repository.history_collection.update_one(
            {"_id": history_id},
            {"$set": {"isDeleted": True}}
        )

        if result.matched_count == 0:
            logger.warning(f"Mensagem com _id {history_id} n√£o encontrada")
            raise HTTPException(
                status_code=404,
                detail=f"Mensagem com ID '{history_id}' n√£o encontrada no hist√≥rico"
            )

        logger.info(f"‚úÖ Mensagem {history_id} marcada como deletada (soft delete)")

        return {
            "success": True,
            "message": f"Mensagem {history_id} marcada como deletada",
            "history_id": history_id
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erro ao marcar mensagem como deletada: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Erro ao marcar mensagem como deletada: {str(e)}"
        )