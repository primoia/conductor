# src/api/routes/agents.py
from fastapi import APIRouter, HTTPException, Path
from typing import List, Dict, Any
from pydantic import BaseModel
from typing import Optional
import logging

# Importar da arquitetura existente
from src.container import container  # Usar inst√¢ncia global do container DI
from src.container import container  # Usar inst√¢ncia global do container DI
from src.api.models import AgentListResponse, AgentSummary, AgentDetailResponse, ValidationResult, AgentCreationRequest, AgentUpdateRequest, VALID_GROUPS
from src.core.services.mongo_task_client import MongoTaskClient

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/agents", tags=["Agents"])

# Modelo existente do server.py
class AgentExecuteRequest(BaseModel):
    user_input: str
    cwd: str
    task_id: str  # REQUIRED: Task ID generated by gateway
    timeout: Optional[int] = 1800  # 30 minutes timeout for long-running operations
    provider: Optional[str] = "claude"
    instance_id: Optional[str] = None  # SAGA-003: Instance ID for isolated context
    context_mode: Optional[str] = "stateless"  # SAGA-003: "stateful" or "stateless"
    conversation_id: Optional[str] = None  # REQUIRED: Conversation ID for context
    screenplay_id: Optional[str] = None  # REQUIRED: Screenplay ID for project context
    wait_for_result: Optional[bool] = True  # If False, returns task_id immediately without waiting
    # Councilor execution fields
    is_councilor_execution: Optional[bool] = False  # Flag for councilor executions
    councilor_config: Optional[Dict[str, Any]] = None  # Councilor configuration (if applicable)

@router.get("/", response_model=AgentListResponse, summary="Listar todos os agentes")
def list_agents():
    """
    Lista todos os agentes dispon√≠veis no sistema.

    Esta rota √© uma vers√£o refatorada do endpoint GET /agents original,
    utilizando os mesmos servi√ßos mas com estrutura modular.
    """
    try:
        conductor_service = container.get_conductor_service()
        agents = conductor_service.discover_agents()

        # Buscar metadados (created_at, group) do MongoDB
        storage_service = container.get_storage_service()
        repository = storage_service.get_repository()
        metadata_map = repository.get_all_agents_metadata()

        # Retornar dados completos do agente
        agent_summaries = []
        for agent in agents:
            metadata = metadata_map.get(agent.agent_id, {})
            created_at = metadata.get("created_at")
            created_at_str = created_at.isoformat() if created_at else None
            group = metadata.get("group", "other")

            agent_summaries.append(
                AgentSummary(
                    id=agent.agent_id,
                    name=getattr(agent, 'name', agent.agent_id),
                    emoji=getattr(agent, 'emoji', 'ü§ñ') or 'ü§ñ',
                    description=getattr(agent, 'description', '') or '',
                    group=group,
                    tags=getattr(agent, 'tags', []) or [],
                    created_at=created_at_str
                )
            )

        return AgentListResponse(total=len(agent_summaries), agents=agent_summaries)

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Erro interno ao processar a lista de agentes: {e}"
        )

@router.get("/{agent_id}/info", response_model=AgentDetailResponse, summary="Obter detalhes de um agente")
def get_agent_info(agent_id: str = Path(..., description="ID do agente a ser consultado")):
    """
    Retorna informa√ß√µes detalhadas de um agente espec√≠fico.

    Utiliza o AgentDiscoveryService para carregar a defini√ß√£o completa do agente.
    """
    try:
        discovery_service = container.get_agent_discovery_service()

        # Verificar se agente existe primeiro
        if not discovery_service.agent_exists(agent_id):
            raise HTTPException(status_code=404, detail=f"Agente '{agent_id}' n√£o encontrado")

        # Carregar defini√ß√£o completa
        definition = discovery_service.get_agent_definition(agent_id)
        if not definition:
            raise HTTPException(status_code=404, detail=f"Defini√ß√£o do agente '{agent_id}' n√£o encontrada")

        return AgentDetailResponse(
            name=definition.name,
            version=definition.version,
            schema_version=definition.schema_version,
            description=definition.description,
            author=definition.author,
            tags=definition.tags,
            capabilities=definition.capabilities,
            allowed_tools=definition.allowed_tools,
            agent_id=definition.agent_id or agent_id
        )

    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Erro interno ao carregar informa√ß√µes do agente: {e}"
        )

@router.get("/{agent_id}/validate", response_model=ValidationResult, summary="Validar configura√ß√£o de um agente")
def validate_agent(agent_id: str = Path(..., description="ID do agente a ser validado")):
    """
    Executa valida√ß√£o completa de um agente espec√≠fico.

    Verifica defini√ß√£o, estrutura de arquivos e integridade de dados.
    """
    try:
        discovery_service = container.get_agent_discovery_service()

        # Usar m√©todo de valida√ß√£o que acabamos de implementar
        is_valid, errors, warnings = discovery_service.validate_agent(agent_id)

        return ValidationResult(
            is_valid=is_valid,
            errors=errors,
            warnings=warnings,
            agent_id=agent_id
        )

    except Exception as e:
        # Se houver erro na valida√ß√£o, retornar como erro de valida√ß√£o
        return ValidationResult(
            is_valid=False,
            errors=[f"Erro durante valida√ß√£o: {str(e)}"],
            warnings=[],
            agent_id=agent_id
        )

@router.post("/", response_model=Dict[str, Any], summary="Criar novo agente")
def create_agent(request: AgentCreationRequest):
    """
    Cria um novo agente no sistema (normalizado para web e terminal).

    Campos obrigat√≥rios:
    - name: deve terminar com _Agent
    - description: 10-200 caracteres
    - persona_content: m√≠nimo 50 chars, deve come√ßar com # (Markdown)

    Campos opcionais:
    - emoji: default ü§ñ
    - tags: lista para busca/organiza√ß√£o
    - mcp_configs: lista de sidecars MCP
    """
    try:
        storage_service = container.get_storage_service()
        repository = storage_service.get_repository()
        discovery_service = container.get_agent_discovery_service()

        # Validar nome (deve terminar com _Agent)
        if not request.name.endswith('_Agent'):
            raise HTTPException(status_code=400, detail="Nome deve terminar com '_Agent'")

        # Validar grupo
        if request.group not in VALID_GROUPS:
            raise HTTPException(
                status_code=400,
                detail=f"Grupo inv√°lido: '{request.group}'. Valores v√°lidos: {', '.join(VALID_GROUPS)}"
            )

        # Validar persona (deve come√ßar com #)
        if not request.persona_content.strip().startswith('#'):
            raise HTTPException(status_code=400, detail="Persona deve come√ßar com cabe√ßalho Markdown (#)")

        # O agent_id √© o pr√≥prio nome (j√° normalizado)
        agent_id = request.name

        # Verificar se j√° existe
        if discovery_service.agent_exists(agent_id):
            raise HTTPException(status_code=409, detail=f"Agente '{agent_id}' j√° existe")

        # Preparar dados da defini√ß√£o (normalizado)
        definition_data = {
            "name": request.name,
            "version": "1.0.0",
            "schema_version": "1.0",
            "description": request.description,
            "author": "PrimoIA",
            "tags": request.tags if request.tags else [],
            "capabilities": [],  # Deprecated - mantido para compatibilidade
            "allowed_tools": [],  # Deprecated - mantido para compatibilidade
            "mcp_configs": request.mcp_configs if request.mcp_configs else [],
            "emoji": request.emoji,
        }

        # Salvar defini√ß√£o (cria diret√≥rio automaticamente)
        # O grupo √© passado separadamente para ser salvo na raiz do documento
        if not repository.save_definition(agent_id, definition_data, group=request.group):
            raise HTTPException(status_code=500, detail="Falha ao salvar defini√ß√£o do agente")

        # Usar persona fornecida pelo usu√°rio (n√£o gerar default)
        if not repository.save_persona(agent_id, request.persona_content):
            raise HTTPException(status_code=500, detail="Falha ao salvar persona do agente")

        # Limpar cache de descoberta
        discovery_service.clear_cache()

        logger.info(f"‚úÖ Agente criado com sucesso: {agent_id}")
        logger.info(f"   - Tags: {request.tags}")
        logger.info(f"   - MCP configs: {request.mcp_configs}")

        return {
            "status": "success",
            "message": "Agente criado com sucesso",
            "agent_id": agent_id,
            "path": repository.get_agent_home_path(agent_id)
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erro ao criar agente: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/{agent_id}", response_model=Dict[str, Any], summary="Atualizar agente existente")
def update_agent(agent_id: str, request: AgentUpdateRequest):
    """
    Atualiza um agente existente no sistema.

    Campos opcionais (apenas os fornecidos ser√£o atualizados):
    - name: nome de exibi√ß√£o
    - description: descri√ß√£o (10-200 chars)
    - group: grupo/categoria
    - emoji: emoji representativo
    - tags: lista de tags
    - persona_content: persona em Markdown (m√≠n 50 chars)
    - mcp_configs: lista de sidecars MCP
    """
    try:
        storage_service = container.get_storage_service()
        repository = storage_service.get_repository()
        discovery_service = container.get_agent_discovery_service()

        # Verificar se o agente existe
        if not discovery_service.agent_exists(agent_id):
            raise HTTPException(status_code=404, detail=f"Agente '{agent_id}' n√£o encontrado")

        # Carregar defini√ß√£o atual
        current_definition = discovery_service.get_agent_definition(agent_id)
        if not current_definition:
            raise HTTPException(status_code=404, detail=f"Defini√ß√£o do agente '{agent_id}' n√£o encontrada")

        # Validar grupo se fornecido
        if request.group is not None and request.group not in VALID_GROUPS:
            raise HTTPException(
                status_code=400,
                detail=f"Grupo inv√°lido: '{request.group}'. Valores v√°lidos: {', '.join(VALID_GROUPS)}"
            )

        # Validar persona se fornecida
        if request.persona_content is not None:
            if not request.persona_content.strip().startswith('#'):
                raise HTTPException(status_code=400, detail="Persona deve come√ßar com cabe√ßalho Markdown (#)")

        # Preparar dados da defini√ß√£o (mesclar com existente)
        definition_data = {
            "name": request.name if request.name is not None else current_definition.name,
            "version": current_definition.version,
            "schema_version": current_definition.schema_version,
            "description": request.description if request.description is not None else current_definition.description,
            "author": current_definition.author,
            "tags": request.tags if request.tags is not None else (current_definition.tags or []),
            "capabilities": current_definition.capabilities or [],
            "allowed_tools": current_definition.allowed_tools or [],
            "mcp_configs": request.mcp_configs if request.mcp_configs is not None else (current_definition.mcp_configs or []),
            "emoji": request.emoji if request.emoji is not None else (current_definition.emoji or "ü§ñ"),
        }

        # Determinar grupo para salvar
        group_to_save = request.group  # Pode ser None se n√£o foi fornecido

        # Salvar defini√ß√£o atualizada
        if not repository.save_definition(agent_id, definition_data, group=group_to_save):
            raise HTTPException(status_code=500, detail="Falha ao atualizar defini√ß√£o do agente")

        # Atualizar persona se fornecida
        if request.persona_content is not None:
            if not repository.save_persona(agent_id, request.persona_content):
                raise HTTPException(status_code=500, detail="Falha ao atualizar persona do agente")

        # Limpar cache de descoberta
        discovery_service.clear_cache()

        logger.info(f"‚úÖ Agente atualizado com sucesso: {agent_id}")
        logger.info(f"   - Campos atualizados: {[k for k, v in request.model_dump().items() if v is not None]}")

        return {
            "status": "success",
            "message": "Agente atualizado com sucesso",
            "agent_id": agent_id,
            "updated_fields": [k for k, v in request.model_dump().items() if v is not None]
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erro ao atualizar agente: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{agent_id}/persona", response_model=Dict[str, Any], summary="Obter persona do agente")
def get_agent_persona(agent_id: str = Path(..., description="ID do agente")):
    """
    Retorna a persona (conte√∫do markdown) de um agente espec√≠fico.
    """
    try:
        storage_service = container.get_storage_service()
        repository = storage_service.get_repository()
        discovery_service = container.get_agent_discovery_service()

        # Verificar se o agente existe
        if not discovery_service.agent_exists(agent_id):
            raise HTTPException(status_code=404, detail=f"Agente '{agent_id}' n√£o encontrado")

        # Carregar persona
        persona_content = repository.load_persona(agent_id)
        if not persona_content:
            return {
                "agent_id": agent_id,
                "persona_content": "",
                "has_persona": False
            }

        return {
            "agent_id": agent_id,
            "persona_content": persona_content,
            "has_persona": True
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erro ao carregar persona do agente: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/{agent_id}/execute", response_model=Dict[str, Any], summary="Executar um agente")
def execute_agent(agent_id: str, request: AgentExecuteRequest):
    """
    Executa um agente espec√≠fico via MongoDB queue system.

    SAGA-004: Hist√≥rico por instance_id √© gerenciado automaticamente via collection 'history'.
    """
    if MongoTaskClient is None:
        raise HTTPException(status_code=503, detail="MongoDB client n√£o est√° dispon√≠vel")

    try:
        task_client = MongoTaskClient()
        discovery_service = container.get_agent_discovery_service()

        # Obter agent_definition para determinar provider com fallback
        agent_definition = discovery_service.get_agent_definition(agent_id)
        if not agent_definition:
            raise HTTPException(status_code=404, detail=f"Agente '{agent_id}' n√£o encontrado")

        # üîç LOG DETALHADO PARA RASTREAR PROVIDER E CONTEXT
        logger.info("üîç [AGENTS] Determinando provider:")
        logger.info(f"   - request.provider: {request.provider}")
        logger.info(f"   - request.context_mode: {request.context_mode}")
        logger.info(f"   - agent_definition: {agent_definition}")
        logger.info(f"   - agent_ai_provider: {getattr(agent_definition, 'ai_provider', 'N/A')}")

        # Determinar provider com fallback hier√°rquico
        provider = container.get_ai_provider(
            agent_definition=agent_definition,
            cli_provider=request.provider
        )
        
        logger.info(f"‚úÖ [AGENTS] Provider final: {provider}")

        # Build XML prompt
        # Note: Se conversation_id for fornecido, o hist√≥rico ser√° buscado da conversa
        # IMPORTANTE: Conselheiros N√ÉO incluem hist√≥rico (cada execu√ß√£o √© independente)
        # mas SALVAM resultados na conversa para visualiza√ß√£o posterior
        # context_mode="stateless" s√≥ se aplica quando N√ÉO h√° conversation_id
        include_history = (
            bool(request.conversation_id) or (request.context_mode != "stateless")
        ) and not request.is_councilor_execution

        logger.info(f"üîç [AGENTS] Decis√£o de hist√≥rico:")
        logger.info(f"   - conversation_id presente: {bool(request.conversation_id)}")
        logger.info(f"   - context_mode: {request.context_mode}")
        logger.info(f"   - is_councilor_execution: {request.is_councilor_execution}")
        logger.info(f"   - include_history final: {include_history}")

        xml_prompt = discovery_service.get_full_prompt(
            agent_id=agent_id,
            current_message=request.user_input,
            meta=False,
            new_agent_id=None,
            include_history=include_history,
            save_to_file=False,
            conversation_id=request.conversation_id,  # üî• REQUIRED: Pass conversation_id to get history
            screenplay_id=request.screenplay_id,  # üî• REQUIRED: Pass screenplay_id for project context
            instance_id=request.instance_id  # üî• REQUIRED: Pass instance_id for isolated context
        )

        # üîç DEBUG: Verificar se o prompt est√° correto
        logger.info(f"üîç [AGENTS] Prompt constru√≠do:")
        logger.info(f"   - Tamanho: {len(xml_prompt)} chars")
        logger.info(f"   - Tem tags XML: {'<persona>' in xml_prompt}")
        logger.info(f"   - Primeiros 200 chars: {xml_prompt[:200]}")

        # Submete a tarefa (task_id vem do gateway)
        task_id = task_client.submit_task(
            task_id=request.task_id,  # üî• Gateway-generated task_id
            agent_id=agent_id,
            cwd=request.cwd,
            timeout=request.timeout,
            provider=provider,
            prompt=xml_prompt,
            instance_id=request.instance_id,  # üî• REQUIRED: Pass instance_id to task
            conversation_id=request.conversation_id,  # üî• REQUIRED: Pass conversation_id to task
            screenplay_id=request.screenplay_id,  # üî• REQUIRED: Pass screenplay_id to task
            is_councilor_execution=request.is_councilor_execution,  # Councilor flag
            councilor_config=request.councilor_config  # Councilor config (if applicable)
        )

        # Check if caller wants to wait for result or get task_id immediately
        if not request.wait_for_result:
            # Return task_id immediately for async/SSE pattern
            logger.info(f"‚úÖ [AGENTS] Task {task_id} submitted, returning immediately (async mode)")
            return {
                "_id": task_id,
                "status": "pending",
                "message": "Task submitted successfully, use task_id to monitor progress"
            }

        # Default behavior: wait for result (blocking)
        logger.info(f"‚è≥ [AGENTS] Waiting for task {task_id} to complete (sync mode)")
        result_document = task_client.get_task_result(task_id=task_id, timeout=request.timeout)

        # SAGA-004: Hist√≥rico j√° foi salvo automaticamente pelo TaskExecutionService
        # com o instance_id correto na collection 'history'

        return result_document

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.put("/history/{history_id}/delete", summary="Marcar mensagem do hist√≥rico como deletada")
def soft_delete_history_message(history_id: str = Path(..., description="ID da mensagem (_id do MongoDB)")):
    """
    Marca uma mensagem do hist√≥rico como deletada (soft delete).

    A mensagem n√£o √© removida do banco, mas recebe o campo isDeleted: true,
    fazendo com que seja exclu√≠da do prompt montado pelo PromptEngine.

    Args:
        history_id: ID √∫nico da mensagem (_id do MongoDB)

    Returns:
        Objeto com success: true/false e message
    """
    try:
        storage_service = container.get_storage_service()
        repository = storage_service.get_repository()

        # Atualizar documento com isDeleted: true
        result = repository.history_collection.update_one(
            {"_id": history_id},
            {"$set": {"isDeleted": True}}
        )

        if result.matched_count == 0:
            logger.warning(f"Mensagem com _id {history_id} n√£o encontrada")
            raise HTTPException(
                status_code=404,
                detail=f"Mensagem com ID '{history_id}' n√£o encontrada no hist√≥rico"
            )

        logger.info(f"‚úÖ Mensagem {history_id} marcada como deletada (soft delete)")

        return {
            "success": True,
            "message": f"Mensagem {history_id} marcada como deletada",
            "history_id": history_id
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erro ao marcar mensagem como deletada: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Erro ao marcar mensagem como deletada: {str(e)}"
        )